<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8"> <!-- Define codificação para UTF-8 -->
  <title>Sun Slayer</title> <!-- Título da aba do navegador -->
  <meta name="viewport" content="width=device-width,initial-scale=1"> <!-- Responsivo para dispositivos móveis -->

  <style>
    :root {
      --cor-principal: #c21414; 
      --cor-texto-vm: rgb(245, 38, 38);
      --cor-fundo: #1a1a1a;   
      --cor-texto: #ffffff;  
      --cor-borda: #444444;   
      --cor-hover: #cc0000;   
    }

    html, body {
      height: 100%; 
      margin: 0; 
    }
    body {
      display:flex; 
      align-items:center; 
      justify-content:center; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    canvas { display:block; background-repeat: repeat;}
    
    /* Overlay para Game Over */
    #overlay {
      position: fixed; top: 0; left: 0; right:0; bottom:0;
      display:flex; 
      align-items:center; 
      justify-content:center;
      background: rgba(0,0,0,0.6);
      color: white; font-family: Arial, sans-serif; z-index: 10;      
      visibility: hidden;
      flex-direction: column; gap: 12px;
    }
    #overlay.visible {visibility: visible;}

    button { 
      padding: 10px 16px; 
      font-size: 16px; 
      border-radius:8px; 
      border:none; 
      cursor:pointer; 
    }

    /* Overlay de escolha de cartas */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000000b0;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none; 
    }
    .container {
      border: 2px solid var(--cor-principal);
      border-radius: 10px;
      background-color: var(--cor-fundo);
      padding: 30px;
      display: grid;
      grid-template-columns: 2fr 1fr; 
      gap: 20px;
      width: 90%;
      max-width: 1200px;
    }

    .main-content {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .header h1 {
      margin: 0;
      font-size: 2em;
      color: var(--cor-hover);
    }

    .header .level {
      font-size: 1.5em;
      font-weight: bold;
      color: var(--cor-hover);
    }

    .card-selection {
      display: flex;
      justify-content: space-around;
      gap: 20px;
      flex-wrap: wrap; 
    }

    .card {
      background-color: #000000d2;
      border: 2px solid #ff3636;
      border-radius: 2px;
      padding: 15px;
      width: 200px;
      min-height: 250px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      text-align: center;
      box-shadow: 0 2px 4px var(--cor-principal);
      transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      cursor: pointer;
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
    }

    .card-title {
      font-size: 1.3em;
      font-weight: bold;
      color: var(--cor-principal);
      margin-bottom: 15px;
    }

    .card-description {
      font-size: 1em;
      color: var(--cor-texto-vm);
      line-height: 1.4;
      font-weight: 500;
    }

    .cancel-button-wrapper {
      display: flex;
      justify-content: center;
      margin-top: 30px;
    }

    .cancel-level-button {
      background-color: #000000d2;
      color: #ff3636;
      padding: 12px 25px;
      border: none;
      border-radius: 5px;
      font-size: 1.1em;
      cursor: pointer;
      transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
    }

    .cancel-level-button:hover {
      background-color: #1a1a1a;
      transform: translateY(-2px);
    }
    .card-image img{
      width: 150px;
    }

    .status-panel {
      border: 2px solid var(--cor-principal);
      border-radius: 8px;
      padding: 15px;
      background-color: #000000d2;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .status-panel h2 {
      margin-top: 0;
      font-size: 1.8em;
      color: var(--cor-hover);
      margin-bottom: 15px;
    }

    .status-item {
      margin-bottom: 8px;
      font-size: 1.05em;
      color: var(--cor-principal);
    }

    .status-item strong {
      color: var(--cor-texto-vm);
      font-weight: 600;
    }

    .separator {
      border-top: 1px dashed #aaa;
      margin: 15px 0;
    }

    .skills-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }

    .skills-list li {
      margin-bottom: 5px;
      font-size: 1em;
      color: #555;
    }


    #name{
      position: fixed;
      top: -10px;
      left: 10px;
      color: white;
    }
    #level{
      position: fixed;
      top: 0px;
      right: 15px;
      color: white;
    }
    #score{
      position: fixed;
      bottom: -10px;
      left: 10px;
      color: white;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas> <!-- Canvas onde o jogo será desenhado -->

  <h1 id="name"></h1>
  <h2 id="level"></h2>
  <h2 id="score"></h2>

  <!-- Overlay de Game Over -->
  <div id="overlay">
    <h1 id="overlayTitle">Game Over</h1> <!-- Título do overlay -->
    <div id="overlayScore">Pontos: 0</div> <!-- Mostra pontuação -->
    <button id="btnRestart">Reiniciar</button> <!-- Botão para reiniciar -->
  </div>

  <!-- Overlay de escolha de cartas -->
  <div class="overlay" id="power-up-overlay">
      <div class="container">
          <div class="main-content">
              <div class="header">
                  <h1>Escolha um novo poder:</h1>
                  <span class="level">level 99</span>
              </div>

              <div class="card-selection">
                  <div class="card">
                      <div class="card-title">carta 1</div>
                      <div class="card-image"><img src="cartas/bonus_vida.png"></div>
                      <div class="card-description">Descricao dos poderes da carta</div>
                  </div>
                  <div class="card">
                      <div class="card-title">carta 1</div>
                      <div class="card-image"><img src="cartas/escudo.png"></div>
                      <div class="card-description">Descricao dos poderes da carta</div>
                  </div>
                  <div class="card">
                      <div class="card-title">carta 1</div>
                      <div class="card-image"><img src="cartas/ladrao.png"></div>
                      <div class="card-description">Descricao dos poderes da carta</div>
                  </div>
              </div>

              <div class="cancel-button-wrapper">
                  <button class="cancel-level-button" onclick="backGame('cancel')">Cancelar volta +25% dos pontos</button>
              </div>
          </div>

          <div class="status-panel">
              <h2>Status do jogador</h2>
              <div class="status-item">Velocidade do jogo: <strong></strong></div>
              <div class="status-item">Deplay de evasão: <strong></strong></div>
              <div class="status-item">Vida atual: <strong></strong></div>
              <div class="status-item">Vida maxima: <strong></strong></div>
              <div class="status-item">Defesa: <strong></strong></div>
              <div class="status-item">Dragões: <strong></strong></div>
              <div class="status-item">Velocidade do jogador: <strong></strong></div>
              <div class="status-item">Tamanho do jogador: <strong></strong></div>
              <div class="status-item">Dano de ataque: <strong></strong></div>
              <div class="status-item">Velocidade de ataque: <strong></strong></div>
              <div class="status-item">Tamanho da bala: <strong></strong></div>
              <div class="status-item">Tamanho dos inimigos: <strong></strong></div>

          </div>
      </div>
  </div>

  <script>
    // --- CONFIGURAÇÕES ---
    const OBJECT_TYPES = [   
      { id: '1', src: 'personagens/dragao.png',    dangerous: true, points: 5,  nivelBase: 1, enemyDamage: 7,  life: 10 },
      { id: '3', src: 'personagens/Gyotaro.png',   dangerous: true, points: 8,  nivelBase: 2, enemyDamage: 10, life: 15 },
      { id: '2', src: 'personagens/dragao2.png',   dangerous: true, points: 12, nivelBase: 3, enemyDamage: 14, life: 20 },
      { id: '4', src: 'personagens/mago.png',      dangerous: true, points: 15, nivelBase: 4, enemyDamage: 18, life: 25 },
      { id: '5', src: 'personagens/zohakuten.png', dangerous: true, points: 20, nivelBase: 5, enemyDamage: 22, life: 30 }, 
      { id: '6', src: 'personagens/urso.png',      dangerous: true, points: 25, nivelBase: 6, enemyDamage: 28, life: 35 },


      { id: '8',  src: 'personagens/mago2.png',     dangerous: true, points: 30, nivelBase: 8,  enemyDamage: 35, life: 45 },
      { id: '9',  src: 'personagens/akaza.png',     dangerous: true, points: 35, nivelBase: 9,  enemyDamage: 40, life: 55 }, 
      { id: '10', src: 'personagens/planta.png',    dangerous: true, points: 40, nivelBase: 10, enemyDamage: 45, life: 65 }, 
      { id: '11', src: 'personagens/Kokoshibu.png', dangerous: true, points: 50, nivelBase: 11, enemyDamage: 55, life: 80 },
      { id: '12', src: 'personagens/bombado.png',   dangerous: true, points: 60, nivelBase: 12, enemyDamage: 65, life: 100 },
      { id: '13', src: 'personagens/muzan.png',     dangerous: true, points: 75, nivelBase: 13, enemyDamage: 80, life: 125 },
        
      
      { id: '7',  src: 'personagens/miniboss.png'},
      { id: '15', src: 'personagens/boss.png'}
    ];


    // Carregar imagens
    const images = {}; // Objeto para armazenar imagens dos objetos
    OBJECT_TYPES.forEach(t => { 
      const img = new Image(); // cria nova imagem
      img.src = t.src;          // define caminho da imagem
      images[t.id] = img;       // armazena na coleção de imagens com a id do objeto
    });


    const params = new URLSearchParams(window.location.search);
    const nome = params.get("nome")
    document.getElementById("name").textContent = nome;

    const bgImg = new Image(); bgImg.src = 'bg.png'; // imagem de fundo
    const playerImg = new Image(); playerImg.src = 'personagens/yoriichi.png'; // imagem do jogador
    const bulletImg = new Image(); bulletImg.src = 'sun.png'; // imagem da bala
    
    const shootSound = new Audio('sons/tiro.mp3'); //som do tiro
    const hitSound = new Audio('sons/dano.mp3'); //som do dano
    const deadSound = new Audio('sons/morte_inimigo.mp3'); //som da morte

    const gameSound = new Audio('sons/backgroundSound.mp4'); //musica do jogo
    const bossSound = new Audio('sons/backgroundBoss.mp4'); //musica do boss
    gameSound.loop = true;
    bossSound.loop = true;
    

    // Canvas full screen
    const canvas = document.getElementById('gameCanvas'); // pega o elemento canvas
    const ctx = canvas.getContext('2d'); // contexto 2D para desenhar
    function resize() { 
      canvas.width = window.innerWidth; // largura total da tela
      canvas.height = window.innerHeight; // altura total da tela
    }
    window.addEventListener('resize', resize); // ajusta tamanho do canvas ao redimensionar janela
    resize(); // chama resize inicialmente






    // Estado do jogo
    let playerSpeed = 9; // velocidade do jogador
    let playerSize = 70; // tamanho do jogador
    let player = { x: canvas.width/2 - 30, y: canvas.height/2 - 30, width: playerSize, height: playerSize, speed: playerSpeed }; // posição, tamanho e velocidade do jogador
    let barraX = player.x - 5; //posicao x da barra de vida
    let barraY = player.y + 75; //posicao y da barra de vida
    let bullets = []; // array para armazenar balas
    let objects = []; // array para armazenar objetos que caem
    let nextLevel = 50; //indica o proximo nivel
    let level = 1; // nivel atual
    let score = 0; // pontuação inicial
    let maxLives = 100; // maximo de vidas
    let lives = 100; // vidas iniciais
    let gameSpeed = 2; // velocidade base de queda dos objetos
    let spawnInterval = 450; // intervalo de spawn em ms
    let lastSpawn = 0; // timestamp do último spawn
    let lastTime = 0; // timestamp do último frame
    let running = true; // flag para saber se o jogo está rodando
    let playerDamage = 5; //dano do jogador
    let bulletSpeed = 12; //velocidade da bala
    let bulletSize = 15; //tamanho da bala
    let enemySize = 60; //tamanho dos inimigos
    let bossFight = false;
    

    //buffs
    let dragons = 0; //numero de dragões
    let defense = 0; //defesa do jogador
    let mana = 1; //mana adicional
    let field = false;

    // Overlay
    const overlay = document.getElementById('overlay'); // overlay de Game Over
    const overlayTitle = document.getElementById('overlayTitle'); // título do overlay
    const overlayScore = document.getElementById('overlayScore'); // pontuação do overlay
    document.getElementById('btnRestart').addEventListener('click', restartGame); // botão reiniciar chama função restartGame

    // Controles do tiro
    let canShoot = true; // variavel pra permitir tiro
    const COOLDOWN = 600; // delay pro próximo tiro 
    if (canShoot) {
      window.addEventListener('mousedown', e => {
        keys[e.key] = true;
        if (e.button === 0) { 
          shoot(); // chama a funcao de tiro
          if(!bossFight){
            gameSound.play();
            bossSound.pause();
          }
        }
      });

      window.addEventListener('keydown', e => {
        keys[e.key] = true;

        if (e.key === "Enter") {
            shoot(); // chama a funcao de tiro

            if (!bossFight) {
                gameSound.play();
                bossSound.pause();
            }
        }
      });
    }
    setTimeout(() => {
      canShoot = true;
    }, COOLDOWN);


    //logica das cartas
    const cards = [
      {
        name: "Volta vida",
        image: "cartas/vida.png",
        description: "Restaura uma quantidade de vida aleatoria",
        effect: "increase_health",
      },
      {
        name: "Bônus de Vida",
        image: "cartas/bonus_vida.png",
        description: "Aumenta permanentemente sua vida máxima em 25 pontos.",
        effect: "increase_max_health",
      },
      {
        name: "Pequenino",
        image: "cartas/diminui.png",
        description: "Diminui seu tamanho em 5px",
        effect: "decrease_size"
      },
      {
        name: "Veloz",
        image: "cartas/velocidade.png",
        description: "Almenta sua velocidade em +3",
        effect: "increase_speed"
      },
      {
        name: "Escudo Mágico",
        image: "cartas/escudo.png",
        description: "Diminui o dano recebido em -5",
        effect: "grant_shield"
      },
      {
        name: "Ladrão de Velocidade",
        image: "cartas/ladrao.png",
        description: "Aumenta sua velocidade em +3 e diminui a dos inimigos em -3.",
        effect: "speed_steal"
      },
      {
        name: "Força Bruta",
        image: "cartas/forca.png",
        description: "Aumenta seu dano em +5",
        effect: "increase_strength",
      },
      {
        name: "Projéteis Maiores",
        image: "cartas/bala.png",
        description: "Aumenta o tamanho da sua bala em +2px.",
        effect: "increase_bullet_size",
      },
      {
        name: "Tiro rapido",
        image: "cartas/bala_rapida.png",
        description: "Aumenta a velocidade da bala em +3.",
        effect: "increase_bullet_speed",
      },
      {
        name: "Dragão amigo",
        image: "cartas/dragao.png",
        description: "Aumenta o numero de dragões +1, porem evasão +100ms e jogo +1.",
        effect: "increase_dragons",
      },
      {
        name: "Pesquisador",
        image: "cartas/mana.png",
        description: "Aumenta o ganho de mana em 0.3 por inimigo.",
        effect: "increase_mana",
      }
    ]; 


    // Escolher tipo de objeto baseado na probabilidade
    function chooseType() {
      const availableTypes = OBJECT_TYPES.filter(t => t.nivelBase <= level);

      if (availableTypes.length === 0) {
          return OBJECT_TYPES[0]; 
      }

      const randomIndex = Math.floor(Math.random() * availableTypes.length);
      
      return availableTypes[randomIndex];
  }

    // Spawn de objetos
    function spawnObject() {
      if (dragons > 0) {
        for (let i = 0; i < dragons; i++) {
          setTimeout(() => {
            shoot()
          }, 400);
        }
      }
      const t = chooseType(); 
      const side = Math.floor(Math.random() * 4); // 0: topo, 1: direita, 2: baixo, 3: esquerda
      let x, y;
      
      switch(side) {
        case 0: // Topo
          x = Math.random() * (canvas.width - enemySize);
          y = -enemySize;
          break;
        case 1: // Direita
          x = canvas.width;
          y = Math.random() * (canvas.height - enemySize);
          break;
        case 2: // Baixo
          x = Math.random() * (canvas.width - enemySize);
          y = canvas.height;
          break;
        case 3: // Esquerda
          x = -enemySize;
          y = Math.random() * (canvas.height - enemySize);
          break;
      }
      
      objects.push({ 
        type: t.id, x, y, width: enemySize, height: enemySize, img: images[t.id], dangerous: t.dangerous, points: t.points, enemyDamage:t.enemyDamage, life: t.life 
      });
    }

    function spawnBoss() {
      if (bossFight) return; // Já está em luta contra o boss

      const x = canvas.width / 2 - enemySize / 2;
      const y = -enemySize * 2 + 50;

      if(level==7){
        setTimeout(() => {
          objects.push({ 
            type: '7', x, y, width: enemySize * 3, height: enemySize * 3, img: images['7'], dangerous: true, points: (nextLevel-score)+100, enemyDamage: lives, life: 2500 
          });
        }, 5000);
      }
      else if(level==15){
        setTimeout(() => {
          objects.push({ 
            type: '15', x, y, width: enemySize * 4, height: enemySize * 4, img: images['15'], dangerous: true, points: (nextLevel-score)+100, enemyDamage: lives, life: 4000 
          });
        }, 5000);
      }

      bossFight = true;
    }

    // Encontrar o inimigo mais próximo
    function findClosestEnemy() {
      if (objects.length === 0) return null;
      
      let closest = null;
      let minDistance = Infinity;
      
      for (const obj of objects) {
        if (!obj.dangerous) continue; // Só considerar inimigos perigosos
        
        const dx = (obj.x + obj.width/2) - (player.x + player.width/2);
        const dy = (obj.y + obj.height/2) - (player.y + player.height/2);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < minDistance) {
          minDistance = distance;
          closest = obj;
        }
      }
      return closest;
    }
    
    
    // Atirar
    function shoot() {
      const closestEnemy = findClosestEnemy();
      let dirX, dirY;
      
      if (closestEnemy) {
        // Calcular direção para o inimigo mais próximo
        const dx = (closestEnemy.x + closestEnemy.width/2) - (player.x + player.width/2);
        const dy = (closestEnemy.y + closestEnemy.height/2) - (player.y + player.height/2);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Normalizar o vetor de direção
        dirX = dx / distance;
        dirY = dy / distance;
      } else {
        // Se não há inimigos, atirar para a direita
        dirX = 1;
        dirY = 0;
      }
      
      
      bullets.push({ 
        x: player.x + player.width/2 - 8, // Centralizado no jogador
        y: player.y + player.height/2 - 8,
        width: bulletSize,
        height: bulletSize,
        speedX: dirX * bulletSpeed, // Velocidade na direção calculada
        speedY: dirY * bulletSpeed
      });
      
      // Ativar cooldown
      lastShotTime = performance.now();
    }


    // Movimento jogador
    const keys = {} // dicionario pra guardar as teclas
    window.addEventListener('keydown', e => {
      keys[e.key] = true; // seta tecla como pressionada
    });
    window.addEventListener('keyup', e => { keys[e.key] = false; }); 
    function movePlayer() {
      if (keys['a'] && player.x > 0) {// esquerda
          player.x -= player.speed;
          barraX -= player.speed;
      }
      if (keys['d'] && player.x < canvas.width - player.width) {//direita
          player.x += player.speed;
          barraX += player.speed;
      }
      if (keys['w'] && player.y > 0) {//cima
          player.y -= player.speed;
          barraY -= player.speed;
      }
      if (keys['s'] && player.y < canvas.height - player.height) {//baixo
          player.y += player.speed;
          barraY += player.speed;
      }
    }

  

    // Atualizar objetos
    function updateObjects(dt) {
      for (let i = objects.length - 1; i >= 0; i--) {
        const o = objects[i];
        
        // Calcula a direção para o jogador
        const dx = player.x + player.width/2 - (o.x + o.width/2);
        const dy = player.y + player.height/2 - (o.y + o.height/2);
        
        // Normaliza o vetor de direção
        const distance = Math.sqrt(dx * dx + dy * dy);
        const dirX = dx / distance;
        const dirY = dy / distance;
        
        // Velocidade base + aumento gradual com pontuação
        const speed = gameSpeed + dt * 0.15;
        
        // Move o inimigo na direção do jogador
        o.x += dirX * speed;
        o.y += dirY * speed;
        
        // Verifica colisão com o jogador
        if (rectIntersect(o, player)) {
          if (o.dangerous) {
            lives -= (o.enemyDamage - defense);
            objects.splice(i, 1);
            hitSound.play(); 

            if (lives <= 0) endGame();
          } else {
            objects.splice(i, 1);
          }
          continue;
        }
        
        // Remove objetos que saíram muito longe da tela
        if (o.x < -100 || o.x > canvas.width + 100 || 
            o.y < -100 || o.y > canvas.height + 100) {
          objects.splice(i, 1);
        }
      }
    }

    // Atualizar balas (movimento horizontal)
    function updateBullets() {
      for (let i = bullets.length -1; i>=0; i--) {
        const b = bullets[i];
        b.x += b.speedX;
        b.y += b.speedY;

        // Remove bala se sair da tela
        if (b.x < -50 || b.x > canvas.width + 50 || 
            b.y < -50 || b.y > canvas.height + 50) {
          bullets.splice(i,1);
          continue;
        }

        // Verifica colisão com objetos
        for (let j = objects.length -1; j>=0; j--) {
          if (rectIntersect(b, objects[j])) {
            objects[j].life -= playerDamage
            if(objects[j].life <= 0){
              score += objects[j].points * mana;
              objects.splice(j,1);
              deadSound.play();
            }
            bullets.splice(i,1);
            break;
          }
        }
      }
    }


    // Colisão retangular
    function rectIntersect(a,b) {
      return !(a.x > b.x + b.width || a.x + a.width < b.x || a.y > b.y + b.height || a.y + a.height < b.y); 
      // retorna true se dois retângulos se sobrepõem
    }


    // Desenhar cena
    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height); // limpa canvas
      ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height); // desenha fundo
      objects.forEach(o => ctx.drawImage(o.img, o.x, o.y, o.width, o.height)); // desenha objetos
      bullets.forEach(b => ctx.drawImage(bulletImg, b.x, b.y, b.width, b.height)); // desenha balas
      ctx.drawImage(playerImg, player.x, player.y, player.width, player.height); // desenha jogador

      // HUD
      const porcentagemVida = (lives / maxLives) * 100;
      const barraLargura = 85;
      const barraAltura = 9;

      // Fundo da barra (vermelho)
      ctx.fillStyle = '#d11313';
      ctx.fillRect(barraX, barraY, barraLargura, barraAltura);

      // Vida atual (verde)
      ctx.fillStyle = 'green';
      ctx.fillRect(barraX, barraY, (porcentagemVida / 100) * barraLargura, barraAltura);

      // Borda da barra
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      ctx.strokeRect(barraX, barraY, barraLargura, barraAltura);
    }

    // Fim de jogo
    function endGame() {
      running = false; // para loop
      overlayScore.textContent = 'Pontos: ' + Math.trunc(score); // atualiza pontuação no overlay
      overlayTitle.textContent = 'Game Over'; // atualiza título
      overlay.classList.add('visible'); // mostra overlay
    }

    // Reiniciar jogo
    function restartGame() {
      objects = []; 
      bullets = []; 
      dragons = 0;
      playerDamage = 5;
      playerSize = 70;
      playerSpeed = 9;
      bulletSize = 15;
      bulletSpeed = 12;
      enemySize = 60;
      lives = 100; 
      maxLives = 100;
      nextLevel = 50; 
      level = 1;
      score = 0;
      spawnInterval = 450;
      gameSpeed = 2; 
      defense = 0;
      mana = 1;
      running = true; 
      overlay.classList.remove('visible'); // esconde overlay
      lastSpawn = performance.now(); // reinicia spawn
      lastTime = performance.now(); // reinicia loop
      requestAnimationFrame(loop); // inicia loop novamente
    }


    let currentSelectedCards = [];
    function levelUp() {
      running = false;  
      objects = []


      document.querySelector('.level').innerHTML = `Nivel ${level}`;

      const statusValues = [
          Math.trunc(gameSpeed), 
          delay =`${spawnInterval}ms`,
          lives,
          maxLives,
          defense,
          dragons,
          playerSpeed,
          playerSize,
          playerDamage,
          bulletSpeed,
          bulletSize,
          enemySize,

      ];
      
      // Iterar sobre os elementos status-item
      const statusItems = document.querySelectorAll('.status-panel .status-item strong');
      statusItems.forEach((strongElement, index) => {
        if (statusValues[index] !== undefined) {
          strongElement.innerHTML = statusValues[index];
        }
      });

      
      const availableIndices = Array.from({length: cards.length}, (_, i) => i);
      currentSelectedCards = []; // Limpa a seleção anterior

      while (currentSelectedCards.length < 3 && availableIndices.length > 0) {
          const randomIndex = Math.floor(Math.random() * availableIndices.length);
          const cardIndex = availableIndices[randomIndex];
          
          currentSelectedCards.push(cards[cardIndex]);
          availableIndices.splice(randomIndex, 1);
      }
      
      
      // 3. **Gerar o HTML das Cartas Usando map() e Template Literals**
      const cardsHTML = currentSelectedCards.map((card, index) => {
          return `
              <div class="card" onclick="selectCard(${index})"> 
                  <div class="card-title">${card.name}</div>
                  <div class="card-image"><img src="${card.image}"></div>
                  <div class="card-description">${card.description}</div>
              </div>
          `;
      }).join('');
      // 4. **Injetar o HTML das Cartas de uma única vez**
      const cardSelectionElement = document.querySelector('.card-selection');
      cardSelectionElement.innerHTML = cardsHTML;
      
      overlayLevel = document.getElementById("power-up-overlay");
      overlayLevel.style.display = "flex";
    }


    // Função de seleção de carta agora usa a variável global 'currentSelectedCards'
    function selectCard(cardIndex) {
        if (currentSelectedCards.length > cardIndex) {
            const selectedCard = currentSelectedCards[cardIndex];
        
        //condicoes para efeito da carta escolhida
        if(selectedCard.effect == "increase_health"){
          let num = Math.floor(Math.random() * (maxLives - lives));

          lives += num;
        }

        else if(selectedCard.effect == "increase_max_health"){
          maxLives += 25;
        }

        else if(selectedCard.effect == "grant_shield"){
          defense += 5;
        }

        else if(selectedCard.effect == "speed_steal"){
          playerSpeed += 3;
          gameSpeed -= 0.3;
        }

        else if(selectedCard.effect == "increase_strength"){
          playerDamage += 5;
        }

        else if(selectedCard.effect == "decrease_size"){
          playerSize -= 5;
        }
        else if(selectedCard.effect == "increase_speed"){
          playerSpeed += 3;
        }
        else if(selectedCard.effect == "increase_bullet_size"){
          bulletSize += 2;
        }
        else if(selectedCard.effect == "increase_bullet_speed"){
          bulletSpeed += 3;
        }
        else if(selectedCard.effect == "increase_dragons"){
          dragons += 1;
          spawnInterval -= 50;
          gameSpeed += 0.5;
        }
        else if(selectedCard.effect == "increase_mana"){
          mana += 0.3;
        }

        backGame(0); // Volta pro jogo
      }
    }


    scoreUpdate = document.getElementById('score');
    levelUpdate = document.getElementById('level');
    // Loop principal
    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = timestamp - lastTime; // delta time
      lastTime = timestamp;

      if (running) {
        if(score >= nextLevel){
          level ++;
          levelUp()
          nextLevel = nextLevel + (level * 60);
          nextLevel = Math.trunc(nextLevel);
        }
        
        
        if (timestamp - lastSpawn > spawnInterval) {
          if(level!=7 && level!=15){
            bossSound.pause();
            gameSound.play();
            spawnObject();
          }
          else{
            gameSound.pause();
            bossSound.play();
            spawnBoss();
          }
          lastSpawn = timestamp; 
        }
      

        updateObjects(dt); // atualiza objetos
        movePlayer();    // atualiza posição do jogador
        updateBullets();   // atualiza balas
        draw();            // redesenha tudo
        requestAnimationFrame(loop); // próximo frame

        levelUpdate.innerHTML = `Nivel: ${level}`;
        scoreUpdate.innerHTML = `Pontuação atual: ${Math.trunc(score)} <br> ${Math.trunc(nextLevel-score)} pontos para nivel ${level+1}`;
      }
    }
    
    function backGame(arg) {
      const overlay_powerup = document.getElementById('power-up-overlay');
      overlay_powerup.style.display = "none";
      if (!running) { 
        if (arg == 'cancel') {
          score = score + ((nextLevel-score) / 4);
          running = true;
          requestAnimationFrame(loop);
        }
        running = true;
        requestAnimationFrame(loop);
      }
    }


    // Inicia jogo quando imagem de fundo carrega
    bgImg.onload = () => { lastSpawn = performance.now(); lastTime = performance.now(); requestAnimationFrame(loop); };
  </script>
</body>
</html>
