<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8"> <!-- Define codificação para UTF-8 -->
  <title>Sun Slayer</title> <!-- Título da aba do navegador -->
  <meta name="viewport" content="width=device-width,initial-scale=1"> <!-- Responsivo para dispositivos móveis -->

  <style>
    :root {
      --cor-principal: #c21414; 
      --cor-texto-vm: rgb(245, 38, 38);
      --cor-fundo: #1a1a1a;   
      --cor-texto: #ffffff;  
      --cor-borda: #444444;   
      --cor-hover: #cc0000;   
    }

    html, body {
      height: 100%; 
      margin: 0; 
    }
    body {
      display:flex; 
      align-items:center; 
      justify-content:center; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    canvas { display:block; background-repeat: repeat;}
    
    

    /* Estilos para tela de Game Over */
    #overlay, .overlay, #overlay-win, #overlay-pause {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      background-color: #000000b0;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    #overlay {
      visibility: hidden;
      color: white;
      flex-direction: column;
      gap: 10px;
    }
    #overlay.visible {visibility: visible;}
    #overlay h1 {
      font-size: 3em;
      margin: 0;
      color: var(--cor-principal);
    }
    #overlay #overlayScore {
      font-size: 1.5em;
      margin-bottom: 20px;
      color: var(--cor-texto-vm);
    }

    #overlay button { 
      background-color: black;
      color: #ff3636;
      padding: 12px 25px;
      border: 1px solid #ff3636;
      border-radius: 5px;
      font-size: 1.1em;
      cursor: pointer;
      transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
    }
    #overlay button:hover {
      background-color: #1a1a1a;
      transform: translateY(-2px);
    }


    /* estilos para o overlay de pausa */
    #overlay-pause {
      display: none;
      flex-direction: column;
    }
    #overlay-pause h1{
      font-size: 3em;
      margin: 0;
      color: var(--cor-principal);
    }
    #overlay-pause p{
      font-size: 1.5em;
      margin: 10px 0 20px 0;
      color: var(--cor-texto-vm);
    }
    #overlay-pause button { 
      background-color: black;
      color: #ff3636;
      padding: 12px 25px;
      border: 1px solid #ff3636;
      border-radius: 5px;
      font-size: 1.1em;
      cursor: pointer;
      transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
      margin: 5px;
    }


    /* estilos para o overlay de vitoria */
    #overlay-win {
      display: none;
      flex-direction: column;
    }
    #overlay-win h1{
      font-size: 3em;
      margin: 0;
      color: var(--cor-principal);
    }
    #overlay-win p{
      font-size: 1.5em;
      margin: 10px 0 20px 0;
      color: var(--cor-texto-vm);
    }
    #overlay-win button { 
      background-color: black;
      color: #ff3636;
      padding: 12px 25px;
      border: 1px solid #ff3636;
      border-radius: 5px;
      font-size: 1.1em;
      cursor: pointer;
      transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
      margin: 5px;
    }

    /* Estilos para escolha de cartas */
    .overlay {
      display: none;
    }
    .container {
      border: 2px solid var(--cor-principal);
      border-radius: 10px;
      background-color: var(--cor-fundo);
      padding: 30px;
      display: grid;
      grid-template-columns: 2fr 1fr; 
      gap: 20px;
      width: 90%;
      max-width: 1200px;
    }

    .main-content {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .header h1 {
      margin: 0;
      font-size: 2em;
      color: var(--cor-hover);
    }

    .header .level {
      font-size: 1.5em;
      font-weight: bold;
      color: var(--cor-hover);
    }

    .card-selection {
      display: flex;
      justify-content: space-around;
      gap: 20px;
      flex-wrap: wrap; 
    }

    .card {
      background-color: #000000d2;
      border: 2px solid #ff3636;
      border-radius: 2px;
      padding: 15px;
      width: 200px;
      min-height: 250px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      text-align: center;
      box-shadow: 0 2px 4px var(--cor-principal);
      transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      cursor: pointer;
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
    }

    .card-title {
      font-size: 1.3em;
      font-weight: bold;
      color: var(--cor-principal);
      margin-bottom: 15px;
    }

    .card-description {
      font-size: 1em;
      color: var(--cor-texto-vm);
      line-height: 1.4;
      font-weight: 500;
    }

    .cancel-button-wrapper {
      display: flex;
      justify-content: center;
      margin-top: 30px;
    }

    .cancel-level-button {
      background-color: #000000d2;
      color: #ff3636;
      padding: 12px 25px;
      border: none;
      border-radius: 5px;
      font-size: 1.1em;
      cursor: pointer;
      transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
    }

    .cancel-level-button:hover {
      background-color: #1a1a1a;
      transform: translateY(-2px);
    }
    .card-image img{
      width: 150px;
    }

    .status-panel {
      border: 2px solid var(--cor-principal);
      border-radius: 8px;
      padding: 15px;
      background-color: #000000d2;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .status-panel h2 {
      margin-top: 0;
      font-size: 1.8em;
      color: var(--cor-hover);
      margin-bottom: 15px;
    }

    .status-item {
      margin-bottom: 8px;
      font-size: 1.05em;
      color: var(--cor-principal);
    }

    .status-item strong {
      color: var(--cor-texto-vm);
      font-weight: 600;
    }

    .separator {
      border-top: 1px dashed #aaa;
      margin: 15px 0;
    }

    .skills-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }

    .skills-list li {
      margin-bottom: 5px;
      font-size: 1em;
      color: #555;
    }


    #name{
      position: fixed;
      top: -10px;
      left: 10px;
      color: var(--cor-texto-vm);
    }
    #level{
      position: fixed;
      top: 0px;
      right: 15px;
      color: var(--cor-texto-vm);
    }
    #score{
      position: fixed;
      bottom: -10px;
      left: 10px;
      color: var(--cor-texto-vm);
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas> <!-- Canvas onde o jogo será desenhado -->

  <h1 id="name"></h1>
  <h2 id="level"></h2>
  <h2 id="score"></h2>

  <!-- Overlay de Game Over -->
  <div id="overlay">
    <h1 id="overlayTitle">Você perdeu!</h1> <!-- Título do overlay -->
    <div id="overlayScore"></div> <!-- Mostra pontuação -->
    <button onclick="restartGame()" id="btnRestart">Tentar novamente</button> <!-- Botão para reiniciar -->
  </div>

  <div id="overlay-win">
    <h1>Você venceu!</h1>
    <P>Parabens, agora você é o ser mais poderoso do universo.</P>
    <button onclick="restartGame()">Jogar denovo</button>
    <button onclick="window.location.href='/'">voltar para o menu</button>
  </div>

  <div id="overlay-pause">
    <h1>Pogo pausado</h1>
    <P>Presione esc novamente para voltar ao jogo</P>
    <button onclick="restartGame()">Reiniciar partida</button>
    <button onclick="window.location.href='/'">voltar para o menu</button>
  </div>

  <!-- Overlay de escolha de cartas -->
  <div class="overlay" id="power-up-overlay">
      <div class="container">
          <div class="main-content">
              <div class="header">
                  <h1>Escolha um novo poder:</h1>
                  <span class="level">level 99</span>
              </div>

              <div class="card-selection">
                  <div class="card">
                      <div class="card-title">carta 1</div>
                      <div class="card-image"><img src="cartas/bonus_vida.png"></div>
                      <div class="card-description">Descricao dos poderes da carta</div>
                  </div>
                  <div class="card">
                      <div class="card-title">carta 1</div>
                      <div class="card-image"><img src="cartas/escudo.png"></div>
                      <div class="card-description">Descricao dos poderes da carta</div>
                  </div>
                  <div class="card">
                      <div class="card-title">carta 1</div>
                      <div class="card-image"><img src="cartas/ladrao.png"></div>
                      <div class="card-description">Descricao dos poderes da carta</div>
                  </div>
              </div>

              <div class="cancel-button-wrapper">
                  <button class="cancel-level-button" onclick="backGame('cancel')">Voltar com +50% dos pontos</button>
              </div>
          </div>

          <div class="status-panel">
              <h2>Status do jogador</h2>
              <div class="status-item">Velocidade do jogo: <strong></strong></div>
              <div class="status-item">Deplay de evasão: <strong></strong></div>
              <div class="status-item">Vida atual: <strong></strong></div>
              <div class="status-item">Vida maxima: <strong></strong></div>
              <div class="status-item">Defesa: <strong></strong></div>
              <div class="status-item">Dragões: <strong></strong></div>
              <div class="status-item">Velocidade do jogador: <strong></strong></div>
              <div class="status-item">Tamanho do jogador: <strong></strong></div>
              <div class="status-item">Dano de ataque: <strong></strong></div>
              <div class="status-item">Velocidade de ataque: <strong></strong></div>
              <div class="status-item">Tamanho da bala: <strong></strong></div>
              <div class="status-item">Tamanho dos inimigos: <strong></strong></div>
          </div>
      </div>
  </div>

  <script>
    // --- CONFIGURAÇÕES ---
      const CARDS = [
      {
        name: "Volta vida",
        image: "cartas/vida.png",
        description: "Restaura uma quantidade de vida aleatoria",
        effect: "increase_health",
      },
      {
        name: "Bônus de Vida",
        image: "cartas/bonus_vida.png",
        description: "Aumenta permanentemente sua vida máxima em 25 pontos.",
        effect: "increase_max_health",
      },
      {
        name: "Pequenino",
        image: "cartas/diminui.png",
        description: "Diminui seu tamanho em 5px",
        effect: "decrease_size"
      },
      {
        name: "Veloz",
        image: "cartas/velocidade.png",
        description: "Almenta sua velocidade em +3",
        effect: "increase_speed"
      },
      {
        name: "Escudo Mágico",
        image: "cartas/escudo.png",
        description: "Diminui o dano recebido em -5",
        effect: "grant_shield"
      },
      {
        name: "Ladrão de Velocidade",
        image: "cartas/ladrao.png",
        description: "Aumenta sua velocidade em +3 e diminui a dos inimigos em -3.",
        effect: "speed_steal"
      },
      {
        name: "Força Bruta",
        image: "cartas/forca.png",
        description: "Aumenta seu dano em +5",
        effect: "increase_strength",
      },
      {
        name: "Projéteis Maiores",
        image: "cartas/bala.png",
        description: "Aumenta o tamanho da sua bala em +2px.",
        effect: "increase_bullet_size",
      },
      {
        name: "Tiro rapido",
        image: "cartas/bala_rapida.png",
        description: "Aumenta a velocidade da bala em +3.",
        effect: "increase_bullet_speed",
      },
      {
        name: "Dragão amigo",
        image: "cartas/dragao.png",
        description: "Aumenta o numero de dragões +1, porem evasão +100ms e jogo +1.",
        effect: "increase_dragons",
      },
      {
        name: "Pesquisador",
        image: "cartas/mana.png",
        description: "Aumenta o ganho de mana em 0.3 por inimigo.",
        effect: "increase_mana",
      }
    ]; 


    const OBJECT_TYPES = [   
      { id: '1', src: 'personagens/dragao.png',    dangerous: true, points: 5,  nivelBase: 1, enemyDamage: 7,  life: 10 },
      { id: '3', src: 'personagens/Gyotaro.png',   dangerous: true, points: 8,  nivelBase: 2, enemyDamage: 10, life: 15 },
      { id: '2', src: 'personagens/dragao2.png',   dangerous: true, points: 12, nivelBase: 3, enemyDamage: 14, life: 20 },
      { id: '4', src: 'personagens/mago.png',      dangerous: true, points: 15, nivelBase: 4, enemyDamage: 18, life: 25 },
      { id: '5', src: 'personagens/zohakuten.png', dangerous: true, points: 20, nivelBase: 5, enemyDamage: 22, life: 30 }, 
      { id: '6', src: 'personagens/urso.png',      dangerous: true, points: 25, nivelBase: 6, enemyDamage: 28, life: 35 },


      { id: '8',  src: 'personagens/mago2.png',     dangerous: true, points: 30, nivelBase: 8,  enemyDamage: 35, life: 45 },
      { id: '9',  src: 'personagens/akaza.png',     dangerous: true, points: 35, nivelBase: 9,  enemyDamage: 40, life: 55 }, 
      { id: '10', src: 'personagens/planta.png',    dangerous: true, points: 40, nivelBase: 10, enemyDamage: 45, life: 65 }, 
      { id: '11', src: 'personagens/Kokoshibu.png', dangerous: true, points: 50, nivelBase: 11, enemyDamage: 55, life: 70 },
      { id: '12', src: 'personagens/bombado.png',   dangerous: true, points: 60, nivelBase: 12, enemyDamage: 65, life: 80 },
      { id: '13', src: 'personagens/muzan.png',     dangerous: true, points: 75, nivelBase: 13, enemyDamage: 80, life: 90 },
        
      
      { id: '7',  src: 'personagens/miniboss.png'},
      { id: '15', src: 'personagens/boss.png'}
    ];


    // Carregar imagens
    const images = {}; // Objeto para armazenar imagens dos objetos
    OBJECT_TYPES.forEach(t => { 
      const img = new Image(); // cria nova imagem
      img.src = t.src;          // define caminho da imagem
      images[t.id] = img;       // armazena na coleção de imagens com a id do objeto
    });


    const params = new URLSearchParams(window.location.search); //pega parametros da url
    const nome = params.get("nome") // pega o nome
    document.getElementById("name").textContent = nome; // mostra o nome na tela

    let gameInfinity = false; // flag para modo infinito
    const infinity = params.get("infinity") // tenta pegar a variavel infinity da url
    if(infinity){ // se tiver parametro
      gameInfinity = true;// ativa modo infinito
    }

    const bgImg = new Image(); bgImg.src = 'bg.png'; // imagem de fundo
    const playerImg = new Image(); playerImg.src = 'personagens/yoriichi.png'; // imagem do jogador
    const bulletImg = new Image(); bulletImg.src = 'sun.png'; // imagem da bala
    
    const shootSound = new Audio('sons/tiro.mp3'); //som do tiro
    const hitSound = new Audio('sons/dano.mp3'); //som do dano
    const deadSound = new Audio('sons/morte_inimigo.mp3'); //som da morte

    const gameSound = new Audio('sons/backgroundSound.mp4'); //musica do jogo=
    gameSound.loop = true;
    
    // Canvas full screen
    const canvas = document.getElementById('gameCanvas'); // pega o elemento canvas
    const ctx = canvas.getContext('2d'); // contexto 2D para desenhar
    function resize() { 
      canvas.width = window.innerWidth; // largura total da tela
      canvas.height = window.innerHeight; // altura total da tela
    }
    window.addEventListener('resize', resize); // ajusta tamanho do canvas ao redimensionar janela
    resize(); // chama resize inicialmente





    // Estado do jogo
    let playerSpeed = 9; // velocidade do jogador
    let playerSize = 70; // tamanho do jogador
    let player = { x: canvas.width/2 - 30, y: canvas.height/2 - 30, width: playerSize, height: playerSize, speed: playerSpeed }; // posição, tamanho e velocidade do jogador
    let playerDamage = 5; // dano do jogador
    let bulletSpeed = 12; // velocidade da bala
    let bulletSize = 15; // tamanho da bala
    let enemySize = 60; // tamanho dos inimigos

    let nextLevel = 50; //indica o proximo nivel
    let level = 1; // nivel atual
    let score = 0; // pontuação inicial

    let lives = 100; // vidas iniciais
    let maxLives = 100; // maximo de vidas
    let barraX = player.x - 5; //posicao x da barra de vida
    let barraY = player.y + 75; //posicao y da barra de vida
    
    let bullets = []; // array para armazenar balas
    let objects = []; // array para armazenar objetos que caem

    let running = true; // flag para saber se o jogo está rodando
    let bossFight = false;
    let gameSpeed = 2; // velocidade base de queda dos objetos
    let lastTime = 0; // timestamp do último frame
    let spawnInterval = 450; // intervalo de spawn em ms
    let lastSpawn = 0; // timestamp do último spawn
    

    //buffs
    let dragons = 0; // numero de dragões
    let defense = 0; // defesa do jogador
    let mana = 1; // multiplicador de mana


    // Overlay
    const overlay = document.getElementById('overlay'); // overlay de Game Over
    const overlayTitle = document.getElementById('overlayTitle'); // título do overlay
    const overlayScore = document.getElementById('overlayScore'); // pontuação do overlay
    document.getElementById('btnRestart').addEventListener('click', restartGame); // botão reiniciar chama função restartGame

    window.addEventListener('keydown', e => {
      keys[e.key] = true;

      if (e.key === "Escape") {
        if (e.repeat) return; // nao faz nada se segurar

        if (running) {
          running = false; // pausa o jogo
          document.getElementById('overlay-pause').style.display = 'flex'; // mostra overlay de pausa
          gameSound.pause(); // pausa a musica
        } else {
          document.getElementById('overlay-pause').style.display = 'none'; // esconde overlay de pausa
          gameSound.play(); // toca a musica
          running = true; // resume o jogo
          lastTime = performance.now(); // 
          requestAnimationFrame(loop); // reinicia o loop do jogo
        }
      }
    });


    // Controles do tiro
    window.addEventListener('mousedown', e => { // atira com clique do mouse
      keys[e.key] = true;
      if (e.button === 0) { 
        shoot(); // chama a funcao de tiro
        gameSound.play();
      }
    });

    window.addEventListener('keydown', e => { // atira com Enter
      keys[e.key] = true;

      if (e.key === "Enter") {
        if (e.repeat) return; // nao faz nada se segurar
        shoot(); // chama a funcao de tiro
        gameSound.play();
      }
    });

  
    // Escolher tipo de objeto baseado na probabilidade
    function chooseType() {
      const availableTypes = OBJECT_TYPES.filter(t => t.nivelBase <= level); // filtra tipos disponíveis pelo nível

      if (availableTypes.length === 0) {
          return OBJECT_TYPES[0]; // retorna o primeiro tipo se nenhum estiver disponível
      }

      const randomIndex = Math.floor(Math.random() * availableTypes.length); // escolhe um aleatório
      
      return availableTypes[randomIndex]; // retorna o tipo escolhido
  }

    // Spawn de objetos
    function spawnObject() {
      if (dragons > 0) { // atira pela quantidade de dragões
        for (let i = 0; i < dragons; i++) {
          setTimeout(() => {
            shoot()
          }, 400);
        }
      }
      const t = chooseType(); // escolhe tipo de objeto
      const side = Math.floor(Math.random() * 4); // 0: cima, 1: direita, 2: baixo, 3: esquerda
      let x, y; // posição inicial
      
      switch(side) { // escolhe a posição inicial baseado no lado
        case 0: // cima
          x = Math.random() * (canvas.width - enemySize);
          y = -enemySize;
          break;
        case 1: // Direita
          x = canvas.width;
          y = Math.random() * (canvas.height - enemySize);
          break;
        case 2: // Baixo
          x = Math.random() * (canvas.width - enemySize);
          y = canvas.height;
          break;
        case 3: // Esquerda
          x = -enemySize;
          y = Math.random() * (canvas.height - enemySize);
          break;
      }
      
      objects.push({ 
        type: t.id, x, y, width: enemySize, height: enemySize, img: images[t.id], dangerous: t.dangerous, points: t.points, enemyDamage:t.enemyDamage, life: t.life 
      });
    }

    // Spawn do boss
    function spawnBoss() {
      if (bossFight) return; // Já está em luta contra o boss
      
      bossFight = true; // ativa a bossFight
      
      const x = canvas.width / 2 - enemySize / 2; // nasce no meio da tela
      const y = -enemySize; // acima da tela

      if(level==7){
        setTimeout(() => {
          objects.push({ 
            type: '7', x, y, width: enemySize * 3, height: enemySize * 3, img: images['7'], dangerous: true, points: (nextLevel-score)+100, enemyDamage: maxLives, life: 1500 
          });
        }, 5000);
      }

      else if(level==15){
        setTimeout(() => {
          objects.push({ 
            type: '15', x, y, width: enemySize * 4, height: enemySize * 4, img: images['15'], dangerous: true, points: (nextLevel-score)+100, enemyDamage: maxLives, life: 2500 
          });
        }, 5000);
      }
    }



    // Encontrar o inimigo mais próximo
    function findClosestEnemy() {
      if (objects.length === 0) return null; // se não tem inimigos retorna null
      
      let closest = null; // inimigo mais próximo
      let minDistance = Infinity; // distância mínima inicial
      
      for (const obj of objects) {
        if (!obj.dangerous) continue; // Só considerar inimigos perigosos
        
        const dx = (obj.x + obj.width/2) - (player.x + player.width/2); // diferença x
        const dy = (obj.y + obj.height/2) - (player.y + player.height/2); // diferença y
        const distance = Math.sqrt(dx * dx + dy * dy); // distância euclidiana
        
        if (distance < minDistance) {
          minDistance = distance; // atualiza a menor distância
          closest = obj; // atualiza o inimigo mais próximo
        }
      }
      return closest; // retorna o inimigo mais próximo
    }
    
    // Atirar
    function shoot() {
      const closestEnemy = findClosestEnemy();
      let dirX, dirY;
      
      if (closestEnemy) {
        const dx = (closestEnemy.x + closestEnemy.width/2) - (player.x + player.width/2); // diferença x
        const dy = (closestEnemy.y + closestEnemy.height/2) - (player.y + player.height/2); // diferença y
        const distance = Math.sqrt(dx * dx + dy * dy); // distância euclidiana
        
        dirX = dx / distance; // direção x normalizada
        dirY = dy / distance; // direção y normalizada
      } else {
        // atirar para a direita se nao tiver inimigos
        dirX = 1;
        dirY = 0;
      }
      
      
      bullets.push({ // adiciona nova bala ao array
        x: player.x + player.width/2 - 8, // sai da posição x do jogador
        y: player.y + player.height/2 - 8, // e da posição y 
        width: bulletSize, // tamanho da bala
        height: bulletSize, // tamanho da bala
        speedX: dirX * bulletSpeed, // Velocidade na direção x do inimigo
        speedY: dirY * bulletSpeed  // Velocidade na direção y do inimigo
      });
      
      // Ativar cooldown
      lastShotTime = performance.now();
    }


    // Movimento jogador
    const keys = {} // dicionario pra guardar as teclas
    window.addEventListener('keydown', e => {
      keys[e.key] = true; // seta tecla como pressionada
    });
    window.addEventListener('keyup', e => { keys[e.key] = false; }); 
    function movePlayer() { // função pra mover o jogador
      if (keys['a'] && player.x > 0) {// esquerda
        player.x -= player.speed;
        barraX -= player.speed;
      }
      if (keys['d'] && player.x < canvas.width - player.width) {//direita
        player.x += player.speed;
        barraX += player.speed;
      }
      if (keys['w'] && player.y > 0) {//cima
        player.y -= player.speed;
        barraY -= player.speed;
      }
      if (keys['s'] && player.y < canvas.height - player.height) {//baixo
        player.y += player.speed;
        barraY += player.speed;
      }
    }



    // Atualizar objetos
    function updateObjects(dt) {
      for (let i = objects.length - 1; i >= 0; i--) {
        const o = objects[i]; // pega o objeto
        
        // Calcula a direção para o jogador
        const dx = player.x + player.width/2 - (o.x + o.width/2); // diferença x
        const dy = player.y + player.height/2 - (o.y + o.height/2); // diferença y
        

        const distance = Math.sqrt(dx * dx + dy * dy); // distância euclidiana
        const dirX = dx / distance; // direção normalizada x
        const dirY = dy / distance; // direção normalizada y
        

        const speed = gameSpeed + dt * 0.15; // almenta a velocidade do jogo com o tempo
        
        // Move o inimigo na direção do jogador
        o.x += dirX * speed; // atualiza posição x
        o.y += dirY * speed; // atualiza posição y
        
        if (rectIntersect(o, player)) { // verifica colisão com o jogador
          if (o.dangerous) {
            lives -= (o.enemyDamage - defense); // reduz vida do jogador
            objects.splice(i, 1); // remove o objeto
            hitSound.play(); // toca som de dano

            if (lives <= 0) gameOver(); //acaba o jogo se vida <= 0
          } else {
            objects.splice(i, 1); // senao remove o objeto
          }
          continue;
        }
        
        // Remove objetos que saíram muito longe da tela
        if (o.x < -100 || o.x > canvas.width + 100 || 
            o.y < -100 || o.y > canvas.height + 100) {
          objects.splice(i, 1);
        }
      }
    }


    // Atualizar balas (movimento horizontal)
    function updateBullets() {
      for (let i = bullets.length -1; i>=0; i--) {
        const b = bullets[i]; // pega a bala
        b.x += b.speedX; // atualiza posição x
        b.y += b.speedY; // atualiza posição y

        // Remove bala se sair da tela
        if (b.x < -50 || b.x > canvas.width + 50 || 
            b.y < -50 || b.y > canvas.height + 50) {
          bullets.splice(i,1);
          continue;
        }

        // Verifica colisão com objetos
        for (let j = objects.length -1; j>=0; j--) {
          if (rectIntersect(b, objects[j])) { // se colidir
            objects[j].life -= playerDamage // diminui vida do inimigo

            if(objects[j].life <= 0){ // se o inimigo morrer
              score += objects[j].points * mana; // aumenta pontuação com multiplicador de mana
              deadSound.play(); // toca som de morte

              if (objects[j].type == '7') {
                bossFight = false; // coloca bossFight como falso
              }
              else if (objects[j].type == '15') {
                if (gameInfinity) {
                  bossFight = false;  // continua o jogo se tiver no modo infinito
                }else {
                  running = false; // para o jogo
                  document.getElementById('overlay-win').style.display = 'flex'; // vence o jogo
                }
              }

              objects.splice(j,1); // remove o inimigo
            }
            bullets.splice(i,1); // remove a bala  
            break;
          }
        }
      }
    }


    // Colisão de hitbox
    function rectIntersect(a,b) {
      return !(a.x > b.x + b.width || a.x + a.width < b.x || a.y > b.y + b.height || a.y + a.height < b.y); 
      // retorna true se dois retângulos se sobrepõem
    }


    // Desenhar cena
    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height); // limpa canvas
      ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height); // desenha fundo
      objects.forEach(o => ctx.drawImage(o.img, o.x, o.y, o.width, o.height)); // desenha objetos
      bullets.forEach(b => ctx.drawImage(bulletImg, b.x, b.y, b.width, b.height)); // desenha balas
      ctx.drawImage(playerImg, player.x, player.y, player.width, player.height); // desenha jogador

      // HUD
      const porcentagemVida = (lives / maxLives) * 100;
      const barraLargura = 85;
      const barraAltura = 9;

      // Fundo da barra (vermelho)
      ctx.fillStyle = '#d11313';
      ctx.fillRect(barraX, barraY, barraLargura, barraAltura);

      // Vida atual (verde)
      ctx.fillStyle = 'green';
      ctx.fillRect(barraX, barraY, (porcentagemVida / 100) * barraLargura, barraAltura);

      // Borda da barra
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      ctx.strokeRect(barraX, barraY, barraLargura, barraAltura);
    }

    // Fim de jogo
    function gameOver() {
      running = false; // para loop
      overlayScore.textContent = 'Pontos: ' + Math.trunc(score); // atualiza pontuação no overlay
      overlay.classList.add('visible'); // mostra overlay
    }

    // Reiniciar jogo
    function restartGame() {
      try {
        localStorage.clear(); // limpa cache da pagina
      } catch (e) {
        console.error(e);
      }
      try {
        sessionStorage.clear(); // limpa sessão
      } catch (e) {
        console.error(e);
      }
      window.location.reload(true); // recarrega a página
    }


    let currentSelectedCards = []; // cartas selecionadas
    function levelUp() {
      running = false; // pausa o jogo
      objects = [] // limpa objetos na tela


      document.querySelector('.level').innerHTML = `Nivel ${level}`;// atualiza nivel no overlay

      const statusValues = [ // valores dos status em sequencia
          Math.trunc(gameSpeed), 
          delay =`${spawnInterval}ms`,
          lives,
          maxLives,
          defense,
          dragons,
          playerSpeed,
          playerSize,
          playerDamage,
          bulletSpeed,
          bulletSize,
          enemySize,
      ];
      
      // selecionar elementos dos status e atualizar valores
      const statusItems = document.querySelectorAll('.status-panel .status-item strong');
      statusItems.forEach((strongElement, index) => {
        if (statusValues[index] !== undefined) {
          strongElement.innerHTML = statusValues[index];
        }
      });


      // selecionar 3 cartas aleatórias
      const availableIndices = Array.from({length: CARDS.length}, (_, i) => i); 
      currentSelectedCards = []; // Limpa a seleção anterior
      while (currentSelectedCards.length < 3 && availableIndices.length > 0) {
          const randomIndex = Math.floor(Math.random() * availableIndices.length); // índice aleatório
          const cardIndex = availableIndices[randomIndex]; // índice da carta
          
          currentSelectedCards.push(CARDS[cardIndex]); // adiciona carta à seleção
          availableIndices.splice(randomIndex, 1); // remove índice para evitar repetição
      }
      
      
      const cardsHTML = currentSelectedCards.map((card, index) => {// gera HTML para cada carta
          return `
              <div class="card" onclick="selectCard(${index})"> 
                  <div class="card-title">${card.name}</div>
                  <div class="card-image"><img src="${card.image}"></div>
                  <div class="card-description">${card.description}</div>
              </div>
          `;
      }).join('');
      const cardSelectionElement = document.querySelector('.card-selection');
      cardSelectionElement.innerHTML = cardsHTML; // atualiza o HTML das cartas
      
      overlayLevel = document.getElementById("power-up-overlay");
      overlayLevel.style.display = "flex"; // mostra overlay de escolha de cartas
    }


    // Selecionar carta
    function selectCard(cardIndex) {
      if (currentSelectedCards.length > cardIndex) {// verifica se o índice é válido
        const selectedCard = currentSelectedCards[cardIndex]; // pega a carta selecionada
        
        //logica dos efeitos das cartas
        if(selectedCard.effect == "increase_health"){
          let num = Math.floor(Math.random() * (maxLives - lives));
          lives += num;
        }

        else if(selectedCard.effect == "increase_max_health"){
          maxLives += 25;
        }

        else if(selectedCard.effect == "grant_shield"){
          defense += 5;
        }

        else if(selectedCard.effect == "speed_steal"){
          playerSpeed += 3;
          gameSpeed -= 0.3;
        }

        else if(selectedCard.effect == "increase_strength"){
          playerDamage += 5;
        }

        else if(selectedCard.effect == "decrease_size"){
          playerSize -= 5;
        }
        else if(selectedCard.effect == "increase_speed"){
          playerSpeed += 3;
        }
        else if(selectedCard.effect == "increase_bullet_size"){
          bulletSize += 2;
        }
        else if(selectedCard.effect == "increase_bullet_speed"){
          bulletSpeed += 3;
        }
        else if(selectedCard.effect == "increase_dragons"){
          dragons += 1;
          spawnInterval -= 50;
          gameSpeed += 0.5;
        }
        else if(selectedCard.effect == "increase_mana"){
          mana += 0.3;
        }

        backGame(0); // Volta pro jogo
      }
    }


    scoreUpdate = document.getElementById('score');
    levelUpdate = document.getElementById('level');
    // Loop principal
    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp; // inicializa último tempo
      const dt = timestamp - lastTime; // delta time
      lastTime = timestamp; // atualiza último tempo

      if (running) {
        if(score >= nextLevel){
          level ++;
          levelUp()
          nextLevel = nextLevel + (level * 60);
          nextLevel = Math.trunc(nextLevel);
        }
        
        
        if (timestamp - lastSpawn > spawnInterval) {
          if(level!=7 && level!=15){
            spawnObject();
            lastSpawn = timestamp; 
          }
          else{
            spawnBoss();
          }
        }
      
        updateObjects(dt); // atualiza objetos
        movePlayer(); // atualiza posição do jogador
        updateBullets(); // atualiza balas
        draw(); // redesenha tudo
        requestAnimationFrame(loop); // próximo frame

        levelUpdate.innerHTML = `Nivel: ${level}`;
        scoreUpdate.innerHTML = `Pontuação atual: ${Math.trunc(score)} <br> ${Math.trunc(nextLevel-score)} pontos para nivel ${level+1}`;
      }
    }
    
    function backGame(arg) {
      const overlay_powerup = document.getElementById('power-up-overlay');
      overlay_powerup.style.display = "none";

      if (arg == 'cancel') {
        score = score + ((nextLevel-score) / 2);
        running = true;
        requestAnimationFrame(loop);
      }else{
        running = true;
        requestAnimationFrame(loop);
      }
    }


    // Inicia jogo quando imagem de fundo carrega
    bgImg.onload = () => { lastSpawn = performance.now(); lastTime = performance.now(); requestAnimationFrame(loop); };
  </script>
</body>
</html>
