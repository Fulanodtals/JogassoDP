<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8"> <!-- Define codificação para UTF-8 -->
  <title>Sun Slayer</title> <!-- Título da aba do navegador -->
  <meta name="viewport" content="width=device-width,initial-scale=1"> <!-- Responsivo para dispositivos móveis -->

  <style>
    html, body {
      height: 100%; 
      margin: 0; 
    } /* Ocupa toda a tela e remove margens padrão */
    body { 
      background: #000; 
      display:flex; 
      align-items:center; 
      justify-content:center; 
    } /* Fundo preto e centraliza conteúdo */
    canvas { display:block; }
    
    /* Overlay para Game Over */
    #overlay {
      position: fixed; top: 0; left: 0; right:0; bottom:0;
      display:flex; 
      align-items:center; 
      justify-content:center;
      background: rgba(0,0,0,0.6);
      color: white; font-family: Arial, sans-serif; z-index: 10;      
      visibility: hidden;
      flex-direction: column; gap: 12px;
    }
    #overlay.visible {visibility: visible;}

    button { 
      padding: 10px 16px; 
      font-size: 16px; 
      border-radius:8px; 
      border:none; 
      cursor:pointer; 
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7); 
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none; 
    }
    .container {
        border: 2px solid #333;
        border-radius: 10px;
        padding: 20px;
        background-color: #fff;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        display: grid;
        grid-template-columns: 2fr 1fr; 
        gap: 20px;
        width: 90%;
        max-width: 1200px;
    }

    .main-content {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }

    .header h1 {
        margin: 0;
        font-size: 2em;
        color: #333;
    }

    .header .level {
        font-size: 1.5em;
        font-weight: bold;
        color: #555;
    }

    .card-selection {
      display: flex;
      justify-content: space-around;
      gap: 20px;
      flex-wrap: wrap; 
    }

    .card {
      border: 2px solid #555;
      border-radius: 2px;
      padding: 15px;
      width: 200px;
      min-height: 250px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      cursor: pointer;
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
    }

    .card-title {
        font-size: 1.3em;
        font-weight: bold;
        color: #444;
        margin-bottom: 15px;
    }

    .card-description {
        font-size: 0.95em;
        color: #292929;
        line-height: 1.4;
    }

    .cancel-button-wrapper {
        display: flex;
        justify-content: center;
        margin-top: 30px;
    }

    .cancel-level-button {
        background-color: #e74c3c;
        color: white;
        padding: 12px 25px;
        border: none;
        border-radius: 5px;
        font-size: 1.1em;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
    }

    .cancel-level-button:hover {
        background-color: #c0392b;
        transform: translateY(-2px);
    }
    .card-image img{
      width: 150px;
    }

    .status-panel {
        border: 2px solid #333;
        border-radius: 8px;
        padding: 15px;
        background-color: #f2f2f2;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .status-panel h2 {
        margin-top: 0;
        font-size: 1.8em;
        color: #333;
        margin-bottom: 15px;
    }

    .status-item {
        margin-bottom: 8px;
        font-size: 1.05em;
        color: #444;
    }

    .status-item strong {
        color: #222;
    }

    .separator {
        border-top: 1px dashed #aaa;
        margin: 15px 0;
    }

    .skills-list {
        list-style-type: none;
        padding: 0;
        margin: 0;
    }

    .skills-list li {
        margin-bottom: 5px;
        font-size: 1em;
        color: #555;
    }


    #name{
      position: fixed;
      top: -10px;
      left: 10px;
      color: white;
    }
    #level{
      position: fixed;
      top: 0px;
      right: 15px;
      color: white;
    }
    #score{
      position: fixed;
      bottom: -10px;
      left: 10px;
      color: white;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas> <!-- Canvas onde o jogo será desenhado -->

  <h1 id="name">Nome do jogador</h1>
  <h2 id="level"></h2>
  <h2 id="score"></h2>

  <!-- Overlay de Game Over -->
  <div id="overlay">
    <h1 id="overlayTitle">Game Over</h1> <!-- Título do overlay -->
    <div id="overlayScore">Pontos: 0</div> <!-- Mostra pontuação -->
    <button id="btnRestart">Reiniciar</button> <!-- Botão para reiniciar -->
  </div>

  <!-- Overlay de escolha de cartas -->
  <div class="overlay" id="power-up-overlay">
      <div class="container">
          <div class="main-content">
              <div class="header">
                  <h1>Escolha um novo poder:</h1>
                  <span class="level">level 99</span>
              </div>

              <div class="card-selection">
                  <div class="card">
                      <div class="card-title">carta 1</div>
                      <div class="card-image"><img src="cartas/bonus_vida.png"></div>
                      <div class="card-description">Descricao dos poderes da carta</div>
                  </div>
                  <div class="card">
                      <div class="card-title">carta 1</div>
                      <div class="card-image"><img src="cartas/escudo.png"></div>
                      <div class="card-description">Descricao dos poderes da carta</div>
                  </div>
                  <div class="card">
                      <div class="card-title">carta 1</div>
                      <div class="card-image"><img src="cartas/ladrao.png"></div>
                      <div class="card-description">Descricao dos poderes da carta</div>
                  </div>
              </div>

              <div class="cancel-button-wrapper">
                  <button class="cancel-level-button" onclick="backGame()">cancelar nivel</button>
              </div>
          </div>

          <div class="status-panel">
              <h2>status</h2>
              <div class="status-item">Velocidade do jogo: <strong></strong></div>
              <div class="status-item">Deplay de evasão: <strong></strong></div>
              <div class="status-item">Vida atual: <strong></strong></div>
              <div class="status-item">Vida maxima: <strong></strong></div>
              <div class="status-item">Defesa: <strong></strong></div>
              <div class="status-item">Velocidade do jogador: <strong></strong></div>
              <div class="status-item">Tamanho do jogador: <strong></strong></div>
              <div class="status-item">Dano de ataque: <strong></strong></div>
              <div class="status-item">Velocidade de ataque: <strong></strong></div>
              <div class="status-item">Tamanho da bala: <strong></strong></div>
              <div class="status-item">Tamanho dos inimigos: <strong></strong></div>

          </div>
      </div>
  </div>

  <script>
    // --- CONFIGURAÇÕES ---
    const OBJECT_TYPES = [   
      { id: '1', src: 'personagens/dragao.png',    dangerous: true, points: 2,  nivelBase: 1,  enemyDamage: 5,  life: 5 },
      { id: '2', src: 'personagens/mago.png',      dangerous: true, points: 4,  nivelBase: 2,  enemyDamage: 10, life: 10},
      { id: '3', src: 'personagens/Gyotaro.png',   dangerous: true, points: 6,  nivelBase: 4,  enemyDamage: 15, life: 15},
      { id: '4', src: 'personagens/zohakuten.png', dangerous: true, points: 8,  nivelBase: 7,  enemyDamage: 15, life: 20}, 
      
      { id: '5', src: 'personagens/akaza.png',     dangerous: true, points: 12, nivelBase: 11, enemyDamage: 25, life: 23}, 
      { id: '6', src: 'personagens/Kokoshibu.png', dangerous: true, points: 16, nivelBase: 15, enemyDamage: 30, life: 30},
      { id: '7', src: 'personagens/muzan.png',     dangerous: true, points: 20, nivelBase: 17, enemyDamage: 35, life: 38}, 
      
      { id: '8', src: 'personagens/miniboss.png',  dangerous: true, points: 30, nivelBase: 10, enemyDamage: 50, life: 38}, 
      { id: '9', src: 'personagens/boss.png',      dangerous: true, points: 13, nivelBase: 20, enemyDamage: 1000, life: 100}, 

    ];


    // Carregar imagens
    const images = {}; // Objeto para armazenar imagens dos objetos
    OBJECT_TYPES.forEach(t => { 
      const img = new Image(); // cria nova imagem
      img.src = t.src;          // define caminho da imagem
      images[t.id] = img;       // armazena na coleção de imagens com a id do objeto
    });

    const bgImg = new Image(); bgImg.src = 'bg.png'; // imagem de fundo
    const playerImg = new Image(); playerImg.src = 'personagens/yoriichi.png'; // imagem do jogador
    const bulletImg = new Image(); bulletImg.src = 'sun.png'; // imagem da bala
    
    const shootSound = new Audio('sons/tiro.mp3'); //som do tiro
    const hitSound = new Audio('sons/dano.mp3'); //som do dano
    const deadSound = new Audio('sons/morte_inimigo.mp3'); //som da morte

    // Canvas full screen
    const canvas = document.getElementById('gameCanvas'); // pega o elemento canvas
    const ctx = canvas.getContext('2d'); // contexto 2D para desenhar
    function resize() { 
      canvas.width = window.innerWidth; // largura total da tela
      canvas.height = window.innerHeight; // altura total da tela
    }
    window.addEventListener('resize', resize); // ajusta tamanho do canvas ao redimensionar janela
    resize(); // chama resize inicialmente






    // Estado do jogo
    let playerSpeed = 5; // velocidade do jogador
    let playerSize = 80; // tamanho do jogador
    let player = { x: canvas.width/2 - 30, y: canvas.height/2 - 30, width: playerSize, height: playerSize, speed: playerSpeed }; // posição, tamanho e velocidade do jogador
    let barraX = player.x - 5; //posicao x da barra de vida
    let barraY = player.y + 75; //posicao y da barra de vida
    let bullets = []; // array para armazenar balas
    let objects = []; // array para armazenar objetos que caem
    let nextLevel = 50; //indica o proximo nivel
    let level = 1; // nivel atual
    let score = 0; // pontuação inicial
    let maxLives = 100; // maximo de vidas
    let lives = 100; // vidas iniciais
    let gameSpeed = 2; // velocidade base de queda dos objetos
    let spawnInterval = 500; // intervalo de spawn em ms
    let lastSpawn = 0; // timestamp do último spawn
    let lastTime = 0; // timestamp do último frame
    let running = true; // flag para saber se o jogo está rodando
    let playerDamage = 5; //dano do jogador
    let bulletSpeed = 12; //velocidade da bala
    let bulletSize = 15; //tamanho da bala
    let enemySize = 70; //tamanho dos inimigos
    

    //buffs
    let dragons = 0; //numero de dragões
    let defense = 0; //defesa do jogador
    let mana = 0; //mana adicional
    let field = false;

    // Overlay
    const overlay = document.getElementById('overlay'); // overlay de Game Over
    const overlayTitle = document.getElementById('overlayTitle'); // título do overlay
    const overlayScore = document.getElementById('overlayScore'); // pontuação do overlay
    document.getElementById('btnRestart').addEventListener('click', restartGame); // botão reiniciar chama função restartGame

    // Controles do tiro
    let canShoot = true; // variavel pra permitir tiro
    const COOLDOWN = 600; // delay pra 
    if (canShoot) {
      window.addEventListener('mousedown', e => {
        keys[e.key] = true;
        if (e.button === 0) { 
          shootSound.currentTime = 0; // reinicia o som caso ele ainda esteja tocando
          shootSound.play(); // toca o som
          shoot(); // chama a funcao de tiro
        }
      });
    }
    setTimeout(() => {
      canShoot = true;
    }, COOLDOWN);

    



    //logica das cartas
    const cards = [
      {
        name: "Volta vida",
        image: "cartas/vida.png",
        description: "Restaura uma quantidade de vida aleatoria",
        effect: "increase_health",
      },
      {
        name: "Bônus de Vida",
        image: "cartas/bonus_vida.png",
        description: "Aumenta permanentemente sua vida máxima em 25 pontos.",
        effect: "increase_max_health",
      },
      {
        name: "Pequenino",
        image: "cartas/diminui.png",
        description: "Diminui seu tamanho em 5px",
        effect: "decrease_size"
      },
      {
        name: "Veloz",
        image: "cartas/velocidade.png",
        description: "Almenta sua velocidade em +5",
        effect: "increase_speed"
      },
      {
        name: "Escudo Mágico",
        image: "cartas/escudo.png",
        description: "Diminui o dano recebido em -4",
        effect: "grant_shield"
      },
      {
        name: "Ladrão de Velocidade",
        image: "cartas/ladrao.png",
        description: "Aumenta sua velocidade em +3 e diminui a dos inimigos em -3.",
        effect: "speed_steal"
      },
      {
        name: "Força Bruta",
        image: "cartas/forca.png",
        description: "Aumenta seu dano em +5",
        effect: "increase_strength",
      },
      {
        name: "Projéteis Maiores",
        image: "cartas/bala.png",
        description: "Aumenta o tamanho da sua bala em +2px.",
        effect: "increase_bullet_size",
      },
      {
        name: "Tiro rapido",
        image: "cartas/bala_rapida.png",
        description: "Aumenta a velocidade da bala em +3.",
        effect: "increase_bullet_speed",
      },
      {
        name: "Dragão amigo",
        image: "cartas/dragao.png",
        description: "Aumenta o numero de dragões +1 e evasão +100ms jogo 50%",
        effect: "increase_dragons",
      },
      {
        name: "Pesquisador",
        image: "cartas/mana.png",
        description: "Aumenta o ganho de mana em +5 por inimigo.",
        effect: "increase_dragons",
      }
    ]; 


    // Escolher tipo de objeto baseado na probabilidade
    function chooseType() {
      const availableTypes = OBJECT_TYPES.filter(t => t.nivelBase <= level);

      if (availableTypes.length === 0) {
          return OBJECT_TYPES[0]; 
      }

      const randomIndex = Math.floor(Math.random() * availableTypes.length);
      
      return availableTypes[randomIndex];
  }

    // Spawn de objetos
    function spawnObject() {
      if (dragons>0) {
        for (let i = 0; i < dragons; i++) {
          let delay = i * 600; 
          setTimeout(() => {
            shoot()
          }, delay);
        }
      }

      const t = chooseType(); 
      const side = Math.floor(Math.random() * 4); // 0: topo, 1: direita, 2: baixo, 3: esquerda
      let x, y;
      
      switch(side) {
        case 0: // Topo
          x = Math.random() * (canvas.width - enemySize);
          y = -enemySize;
          break;
        case 1: // Direita
          x = canvas.width;
          y = Math.random() * (canvas.height - enemySize);
          break;
        case 2: // Baixo
          x = Math.random() * (canvas.width - enemySize);
          y = canvas.height;
          break;
        case 3: // Esquerda
          x = -enemySize;
          y = Math.random() * (canvas.height - enemySize);
          break;
      }
      
      objects.push({ 
        type: t.id, x, y, width: enemySize, height: enemySize, img: images[t.id], dangerous: t.dangerous, points: t.points, enemyDamage:t.enemyDamage, life: t.life 
      });
    }


    // Encontrar o inimigo mais próximo
    function findClosestEnemy() {
      if (objects.length === 0) return null;
      
      let closest = null;
      let minDistance = Infinity;
      
      for (const obj of objects) {
        if (!obj.dangerous) continue; // Só considerar inimigos perigosos
        
        const dx = (obj.x + obj.width/2) - (player.x + player.width/2);
        const dy = (obj.y + obj.height/2) - (player.y + player.height/2);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < minDistance) {
          minDistance = distance;
          closest = obj;
        }
      }
      return closest;
    }
    
    
    // Atirar
    function shoot() {
      const closestEnemy = findClosestEnemy();
      let dirX, dirY;
      
      if (closestEnemy) {
        // Calcular direção para o inimigo mais próximo
        const dx = (closestEnemy.x + closestEnemy.width/2) - (player.x + player.width/2);
        const dy = (closestEnemy.y + closestEnemy.height/2) - (player.y + player.height/2);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Normalizar o vetor de direção
        dirX = dx / distance;
        dirY = dy / distance;
      } else {
        // Se não há inimigos, atirar para a direita
        dirX = 1;
        dirY = 0;
      }
      
      
      bullets.push({ 
        x: player.x + player.width/2 - 8, // Centralizado no jogador
        y: player.y + player.height/2 - 8,
        width: bulletSize,
        height: bulletSize,
        speedX: dirX * bulletSpeed, // Velocidade na direção calculada
        speedY: dirY * bulletSpeed
      });
      
      // Ativar cooldown
      lastShotTime = performance.now();
    }


    // Movimento jogador
    const keys = {} // dicionario pra guardar as teclas
    window.addEventListener('keydown', e => {
      keys[e.key] = true; // seta tecla como pressionada
    });
    window.addEventListener('keyup', e => { keys[e.key] = false; }); 
    function movePlayer() {
      if (keys['a'] && player.x > 0) {// esquerda
          player.x -= player.speed;
          barraX -= player.speed;
      }
      if (keys['d'] && player.x < canvas.width - player.width) {//direita
          player.x += player.speed;
          barraX += player.speed;
      }
      if (keys['w'] && player.y > 0) {//cima
          player.y -= player.speed;
          barraY -= player.speed;
      }
      if (keys['s'] && player.y < canvas.height - player.height) {//baixo
          player.y += player.speed;
          barraY += player.speed;
      }
    }

  

    // Atualizar objetos
    function updateObjects(dt) {
      for (let i = objects.length - 1; i >= 0; i--) {
        const o = objects[i];
        
        // Calcula a direção para o jogador
        const dx = player.x + player.width/2 - (o.x + o.width/2);
        const dy = player.y + player.height/2 - (o.y + o.height/2);
        
        // Normaliza o vetor de direção
        const distance = Math.sqrt(dx * dx + dy * dy);
        const dirX = dx / distance;
        const dirY = dy / distance;
        
        // Velocidade base + aumento gradual com pontuação
        const speed = gameSpeed + dt * 0.15;
        
        // Move o inimigo na direção do jogador
        o.x += dirX * speed;
        o.y += dirY * speed;
        
        // Verifica colisão com o jogador
        if (rectIntersect(o, player)) {
          if (o.dangerous) {
            lives -= (o.enemyDamage - defense);
            objects.splice(i, 1);
            hitSound.play(); 

            if (lives <= 0) endGame();
          } else {
            score += (o.points + mana);
            objects.splice(i, 1);
          }
          continue;
        }
        
        // Remove objetos que saíram muito longe da tela
        if (o.x < -100 || o.x > canvas.width + 100 || 
            o.y < -100 || o.y > canvas.height + 100) {
          objects.splice(i, 1);
        }
      }
    }

    // Atualizar balas (movimento horizontal)
    function updateBullets() {
      for (let i = bullets.length -1; i>=0; i--) {
        const b = bullets[i];
        b.x += b.speedX;
        b.y += b.speedY;

        // Remove bala se sair da tela
        if (b.x < -50 || b.x > canvas.width + 50 || 
            b.y < -50 || b.y > canvas.height + 50) {
          bullets.splice(i,1);
          continue;
        }

        // Verifica colisão com objetos
        for (let j = objects.length -1; j>=0; j--) {
          if (rectIntersect(b, objects[j])) {
            score += objects[j].points || 50;
            objects[j].life -= playerDamage
            if(objects[j].life <= 0){
              objects.splice(j,1);
              deadSound.play();
            }
            bullets.splice(i,1);
            break;
          }
        }
      }
    }


    // Colisão retangular
    function rectIntersect(a,b) {
      return !(a.x > b.x + b.width || a.x + a.width < b.x || a.y > b.y + b.height || a.y + a.height < b.y); 
      // retorna true se dois retângulos se sobrepõem
    }


    // Desenhar cena
    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height); // limpa canvas
      ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height); // desenha fundo
      objects.forEach(o => ctx.drawImage(o.img, o.x, o.y, o.width, o.height)); // desenha objetos
      bullets.forEach(b => ctx.drawImage(bulletImg, b.x, b.y, b.width, b.height)); // desenha balas
      ctx.drawImage(playerImg, player.x, player.y, player.width, player.height); // desenha jogador

      // HUD
      const porcentagemVida = (lives / maxLives) * 100;
      const barraLargura = 85;
      const barraAltura = 9;

      // Fundo da barra (vermelho)
      ctx.fillStyle = '#d11313';
      ctx.fillRect(barraX, barraY, barraLargura, barraAltura);

      // Vida atual (verde)
      ctx.fillStyle = 'green';
      ctx.fillRect(barraX, barraY, (porcentagemVida / 100) * barraLargura, barraAltura);

      // Borda da barra
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      ctx.strokeRect(barraX, barraY, barraLargura, barraAltura);
    }

    // Fim de jogo
    function endGame() {
      running = false; // para loop
      overlayScore.textContent = 'Pontos: ' + score; // atualiza pontuação no overlay
      overlayTitle.textContent = 'Game Over'; // atualiza título
      overlay.classList.add('visible'); // mostra overlay
    }

    // Reiniciar jogo
    function restartGame() {
      objects = []; bullets = []; score = 0; lives = 100; gameSpeed = 1; running = true; 
      overlay.classList.remove('visible'); // esconde overlay
      lastSpawn = performance.now(); // reinicia spawn
      lastTime = performance.now(); // reinicia loop
      requestAnimationFrame(loop); // inicia loop novamente
    }


    let currentSelectedCards = [];
    function levelUp() {
      running = false;  
      objects = []


      document.querySelector('.level').innerHTML = `Nivel ${level}`;

      const statusValues = [
          gameSpeed, 
          delay =`${spawnInterval}ms`,
          lives,
          maxLives,
          defense,
          playerSpeed,
          playerSize,
          playerDamage,
          bulletSpeed,
          bulletSize,
          enemySize,
      ];
      
      // Iterar sobre os elementos status-item
      const statusItems = document.querySelectorAll('.status-panel .status-item strong');
      statusItems.forEach((strongElement, index) => {
          if (statusValues[index] !== undefined) {
              strongElement.innerHTML = statusValues[index];
          }
      });

      
      const availableIndices = Array.from({length: cards.length}, (_, i) => i);
      currentSelectedCards = []; // Limpa a seleção anterior

      while (currentSelectedCards.length < 3 && availableIndices.length > 0) {
          const randomIndex = Math.floor(Math.random() * availableIndices.length);
          const cardIndex = availableIndices[randomIndex];
          
          currentSelectedCards.push(cards[cardIndex]);
          availableIndices.splice(randomIndex, 1);
      }
      
      
      // 3. **Gerar o HTML das Cartas Usando map() e Template Literals**
      const cardsHTML = currentSelectedCards.map((card, index) => {
          return `
              <div class="card" onclick="selectCard(${index})"> 
                  <div class="card-title">${card.name}</div>
                  <div class="card-image"><img src="${card.image}"></div>
                  <div class="card-description">${card.description}</div>
              </div>
          `;
      }).join('');
      // 4. **Injetar o HTML das Cartas de uma única vez**
      const cardSelectionElement = document.querySelector('.card-selection');
      cardSelectionElement.innerHTML = cardsHTML;
      
      overlayLevel = document.getElementById("power-up-overlay");
      overlayLevel.style.display = "flex";
    }


    // Função de seleção de carta agora usa a variável global 'currentSelectedCards'
    function selectCard(cardIndex) {
        if (currentSelectedCards.length > cardIndex) {
            const selectedCard = currentSelectedCards[cardIndex];
        
        //condicoes para efeito da carta escolhida
        if(selectedCard.effect == "increase_health"){
          let num = Math.floor(Math.random() * (maxLives - lives));

          lives += num;
        }

        else if(selectedCard.effect == "increase_max_health"){
          maxLives += 25;
        }

        else if(selectedCard.effect == "grant_shield"){
          defense += 4;
        }

        else if(selectedCard.effect == "speed_steal"){
          playerSpeed += 3;
          gameSpeed -= 0.3;
        }

        else if(selectedCard.effect == "increase_strength"){
          playerDamage += 4;
        }

        else if(selectedCard.effect == "decrease_size"){
          playerSize -= 5;
        }
        else if(selectedCard.effect == "increase_speed"){
          playerSpeed += 5;
        }
        else if(selectedCard.effect == "increase_bullet_size"){
          bulletSize += 2;
        }
        else if(selectedCard.effect == "increase_bullet_speed"){
          bulletSpeed += 3;
        }
        else if(selectedCard.effect == "increase_dragons"){
          dragons += 1;
          spawnInterval += 100;
          gameSpeed += 0.5;
        }

        backGame(); // Volta pro jogo
      }
    }



    function backGame() {
      const overlay_powerup = document.getElementById('power-up-overlay');
      overlay_powerup.style.display = "none";
      if (!running) { 
        running = true;
        requestAnimationFrame(loop);
      }
    }

    scoreUpdate = document.getElementById('score');
    levelUpdate = document.getElementById('level');
    // Loop principal
    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = timestamp - lastTime; // delta time
      lastTime = timestamp;

      if (running) {
        if (timestamp - lastSpawn > spawnInterval) { spawnObject(); lastSpawn = timestamp; } // spawn objetos
        movePlayer();    // atualiza posição do jogador
        updateObjects(dt); // atualiza objetos
        updateBullets();   // atualiza balas
        draw();            // redesenha tudo
        requestAnimationFrame(loop); // próximo frame

        if(score >= nextLevel){
          level ++;
          levelUp()
          nextLevel = nextLevel + (level * 50);
          nextLevel = Math.trunc(nextLevel);
        }

        levelUpdate.innerHTML = `Nivel: ${level}`;
        scoreUpdate.innerHTML = `Pontuação atual: ${score} <br> ${nextLevel-score} pontos para nivel ${level+1}`;

      }
    }

    // Inicia jogo quando imagem de fundo carrega
    bgImg.onload = () => { lastSpawn = performance.now(); lastTime = performance.now(); requestAnimationFrame(loop); };
  </script>
</body>
</html>
